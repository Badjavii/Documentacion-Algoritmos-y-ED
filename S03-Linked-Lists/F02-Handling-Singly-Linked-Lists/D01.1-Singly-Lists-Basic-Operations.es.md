# Operaciones Básicas de Listas Simplemente Enlazadas 

Las operaciones básicas de las listas simplemente enlazadas son: Inserción de Nodos, Eliminación de Nodos y Búsqueda de Nodos.

Estas operaciones se realizarán mediante funciones. De esta forma, se podrán implementar en cualquier tipo de código.

En este apartado se explicará la teoría de las funciones de las operaciones básicas para el manejo de las listas simplemente enlazadas. En [Singly-Linked Lists Menu](/S03-Linked-Lists/F02-Handling-Singly-Linked-Lists/E00-Singly-Lists-Menu.cpp) se visualiza un programa en C++ donde se ponen en práctica las operaciones básicas que se explicarán en este apartado.

## Inserción en Listas Simplemente Enlazadas

Para la inserción se desarrollará una función `void` que llamarames `inserSL`. Al llamarla, esta función esperará que le pasemos 2 parámetros: un puntero a un Nodo (que será la lista por referencia) y un entero.

```cpp
void insertSL(NodeSL **list, int x){};
```

Luego se inicializa un nuevo apuntador temporal `t` al que se le asigna un nuevo nodo de lista simple. A ese nodo le agregaremos el dato entero `x` que está como parámetro.

```cpp
NodeSL *t = new NodeSL; // Crear un nuevo nodo
t->value = x;           // Asignar el valor al nodo
```

Al nodo siguiente del nuevo nodo le asignaremos la lista pasada como parámetro por referencia. Por último, redefinimos la lista asignándole el nodo temporal.

```cpp
t->prox = *list; // Apuntar el nuevo nodo al inicio de la lista
*list = t;       // Actualizar el inicio de la lista para que apunte al nuevo nodo
```

La función completa se ve de la siguiente forma:

```cpp
void insertSL(NodeSL **list, int x) {
    NodeSL *t = new NodeSL; // Crear un nuevo nodo
    t->value = x;           // Asignar el valor al nodo
    t->prox = *list;        // Apuntar el nuevo nodo al inicio de la lista
    *list = t;              // Actualizar el inicio de la lista para que apunte al nuevo nodo
};
```

### Inserción por el nodo cola de la lista simplemente enlazada

La inserción por cola, a diferencia de la inserción normal, esta se centra en agregar los nodos por el final de la lista, es decir, cada nodo insertado en la lista, se convertira en el nuevo nodo cola de la lista. 

Al igual que la inserción normal, aquí también se desarrollará una función `void` que llamarames `inserSL`. Al llamarla, esta función esperará que le pasemos 2 parámetros: un puntero a un Nodo (que será la lista por referencia) y un entero.

```cpp
void insertSL(NodeSL **list, int x){};
```

Primero, se inicializa un nuevo apuntador temporal `t` al que se le asigna un nuevo nodo de lista simple. A ese nodo le agregaremos el dato entero `x` que está como parámetro.

```cpp
NodeSL *t = new NodeSL; // Crear un nuevo nodo
t->value = x;           // Asignar el valor al nodo
t->prox = NULL;      // El nuevo nodo será el último, así que su prox es nullptr
```

Luego, verificamos si la lista está vacía. Si es así, el nuevo nodo se convierte en el primer nodo de la lista, sino recorre la lista hasta el final y añade el nuevo nodo.

```cpp
if (!*list) 
    *list = t; // Si la lista está vacía, el nuevo nodo será el primero
else {
    // Si la lista no está vacía, recorrer hasta el final y añadir el nuevo nodo
    NodeSL *temp = *list;
    while (temp->prox) 
        temp = temp->prox; // Avanzar hasta el último nodo
    temp->prox = t; // Añadir el nuevo nodo al final de la lista
}
```

La función completa se ve de la siguiente forma:

```cpp
void insertSL(NodeSL **list, int x) {
    NodeSL *t = new NodeSL; // Crear un nuevo nodo
    t->value = x;           // Asignar el valor al nodo
    t->prox = NULL;      // El nuevo nodo será el último, así que su prox es nullptr

    if (!*list) 
        // Si la lista está vacía, el nuevo nodo será el primero
        *list = t;
    else {
        // Si la lista no está vacía, recorrer hasta el final y añadir el nuevo nodo
        NodeSL *temp = *list;
        while (temp->prox) 
            temp = temp->prox;
        temp->prox = t;
    }
}
```

## Eliminación en Listas Simplemente Enlazadas

La eliminación en la listas simplemente enlazadas requieren de un manejo especifico de los punteros. Tenemos que evitar el problema esencial que es perder el puntero cabeza o la conexión con otros nodos despues de la eliminación.

Para la eliminación, desarrollaremos una función `void` llamada `deleteSL`. Esta función recibirá dos parámetros: un puntero a un Nodo (la lista por referencia) y un entero que representa el valor del nodo a eliminar.

```cpp
void deleteSL(NodeSL **list, int x){};
```

Primero, se inicializan dos apuntadores: `t` que apunta al primer nodo de la lista y `prev` que se inicializa como `NULL`.

```cpp
NodeSL *t = *list; // Apuntar al primer nodo de la lista
NodeSL *prev = NULL; // Inicializar el nodo previo como NULL
```

Luego, se recorre la lista buscando el nodo con el valor `x`. Durante este recorrido, `prev` se actualiza para seguir el nodo anterior a `t`.

```cpp
while ((t) && (t->value != x)) {
    prev = t; // Actualizar el nodo previo
    t = t->prox; // Avanzar al siguiente nodo
}
```

Si `t` es `NULL` después del bucle, significa que el valor de `x` no se encontró en la lista.

```cpp
if (!t) {
    cout << "Value not found in the list.\n";
    return;
}
```

Si `prev` es `NULL`, significa que el nodo a eliminar es el primer nodo de la lista. En este caso, se actualiza el puntero de la lista para que apunte al siguiente nodo.

```cpp
if (!prev) {
    *list = t->prox; // Eliminar el primer nodo
} else {
    prev->prox = t->prox; // Saltar el nodo a eliminar
}
```

Finalmente, se elimina el nodo `t` y se imprime un mensaje de confirmación.

```cpp
delete t; // Eliminar el nodo
cout << "Node with value " << x << " deleted.\n";
```

La función completa se ve de la siguiente forma:

```cpp
void deleteSL(NodeSL **list, int x)
{
    NodeSL *t = *list; // Apuntar al primer nodo de la lista
    NodeSL *prev = NULL; // Inicializar el nodo previo como NULL

    // Recorrer la lista buscando el nodo con el valor x
    while ((t) && (t->value != x))
    {
        prev = t; // Actualizar el nodo previo
        t = t->prox; // Avanzar al siguiente nodo
    };

    // Si no se encuentra el nodo con el valor x
    if (!t)
    {
        cout << "Value not found in the list.\n"; // Imprimir mensaje de error
        return; // Salir de la función
    };

    // Si el nodo a eliminar es el primero de la lista
    if (!prev)
        *list = t->prox; // Actualizar el inicio de la lista
    else
        prev->prox = t->prox; // Saltar el nodo a eliminar

    delete t; // Eliminar el nodo
    cout << "Node with value " << x << " deleted.\n"; // Imprimir mensaje de confirmación
};
```

## Busqueda en Listas Simplemente Enlazadas